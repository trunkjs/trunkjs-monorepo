# API Reference

This page documents the public API exposed by @trunkjs/prolit.

Imports
```ts
import {
  prolit_html,
  ProLitTemplate,
  prolit_compile,
  scopeDefine,
  litEnv,
  type ProlitGeneratedRendererFn,
  type LitEnv,
} from '@trunkjs/prolit';
```

prolit_html
Signature
```ts
function prolit_html(strings: TemplateStringsArray, ...values: any[]): ProLitTemplate
```
Usage
```ts
const tpl = prolit_html`<div>{{ name }}</div>`;
```
- Produces a ProLitTemplate from a template literal (recommended).

class ProLitTemplate
Constructor
```ts
new ProLitTemplate(template: string, scope?: ScopeDefinition)
```
- If scope is provided, the instance assigns itself to scope.$tpl.

Members
- scope: ScopeDefinition | null

Methods
```ts
render(): any // lit-html TemplateResult
renderInElement(element: HTMLElement): void
renderIntoElement(element: HTMLElement): void
```
Notes
- render() compiles on first call and returns a lit-html TemplateResult.
- render(In|Into)Element() render into a regular DOM element using lit-html’s render.

prolit_compile
Signature
```ts
function prolit_compile(templateString: string): ProlitGeneratedRendererFn
```
- Parses and compiles a template string to a renderer function.
- Low-level API; most users should prefer prolit_html + ProLitTemplate.

Types
```ts
type ProlitGeneratedRendererFn = (scope: any, $$__litEnv: LitEnv) => any; // TemplateResult
```

scopeDefine
Signature
```ts
function scopeDefine<T extends object & ScopeDefinition>(scope: T): T & ScopeDefinition
```

ScopeDefinition (selected fields)
```ts
interface ScopeDefinition {
  // user state fields (your data) ...

  $tpl?: ProLitTemplate | string; // recommended: ProLitTemplate via prolit_html
  $this?: import('lit').LitElement; // set to your component instance
  $update?: () => void;             // calls $this.requestUpdate()

  // utilities
  $raw?: object & ScopeDefinition;      // raw object
  $rawPure?: object & ScopeDefinition;  // non-$ fields only

  // reserved / optional
  $fn?: Record<string, (...args: any[]) => any>;
  $hooks?: {
    $init?: () => void;
    $beforeRender?: () => void;
    $afterRender?: () => void;
    $onceBeforeRender?: () => void;
    $onceAfterRender?: () => void;
  };
  $on?: Record<string, (event: Event) => void>;
  $ref?: Record<string, HTMLElement | null>;
}
```

Behavior
- When scope.$this is set to a LitElement instance:
  - scope.$update() triggers requestUpdate().
  - Assignments to non-$ properties trigger requestUpdate() automatically via Proxy set trap.
- Assigning a ProLitTemplate to $tpl sets tpl.scope = scope.
- Accessing $tpl before it is defined throws a descriptive error.

Recommended usage
```ts
const scope = scopeDefine({
  title: 'Hello',
  items: ['a', 'b'],
  $tpl: prolit_html`
    <h1>{{ title }}</h1>
    <ul><li *for="x of items">{{ x }}</li></ul>
  `,
});
```

litEnv
Signature
```ts
function litEnv(): { html, repeat, when }
```
- Returns utilities used by generated renderers:
  - html from lit-html
  - repeat from lit-html/directives/repeat.js
  - when from lit/directives/when.js
- Internal helper; only needed if you call a ProlitGeneratedRendererFn directly.

Error handling
- ProLitTemplate.render() rethrows rendering errors with an augmented message including the generated function’s line context to aid debugging.
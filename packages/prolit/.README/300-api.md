# API Reference

Imports
```ts
import {
  prolit_html,
  ProLitTemplate,
  prolit_compile,
  scopeDefine,
  litEnv,
  type ProlitGeneratedRendererFn,
  type LitEnv,
} from '@trunkjs/prolit';
```

## prolit_html

Signature
```ts
function prolit_html(strings: TemplateStringsArray, ...values: any[]): ProLitTemplate
```

Usage
```ts
const tpl = prolit_html`<div>{{ name }}</div>`;
```

## class ProLitTemplate

Constructor
```ts
new ProLitTemplate(template: string, scope?: ScopeDefinition)
```

Members
- `scope: ScopeDefinition | null`

Methods
```ts
render(): any // lit-html TemplateResult
renderInElement(element: HTMLElement): void
renderIntoElement(element: HTMLElement): void
```

Notes
- `render()` compiles on first call and returns a lit-html TemplateResult.

## prolit_compile

Signature
```ts
function prolit_compile(templateString: string): ProlitGeneratedRendererFn
```

## Types

```ts
type ProlitGeneratedRendererFn = (scope: any, $$__litEnv: LitEnv) => any; // TemplateResult

type LitEnv = {
  html: any;
  repeat: import('lit-html/directives/repeat.js').RepeatDirectiveFn;
  when: any;
  styleMap: any;
  classMap: any;
};
```

## scopeDefine

Signature
```ts
function scopeDefine<T extends object & ScopeDefinition>(scope: T): T & ScopeDefinition
```

Behavior
- When `scope.$this` is a LitElement instance:
  - `scope.$update()` triggers `requestUpdate()`.
  - Assignments to non-$ properties trigger `requestUpdate()` automatically.
- Assigning a `ProLitTemplate` to `$tpl` sets `tpl.scope = scope`.
- Accessing `$tpl` before it is defined throws.

Recommended usage
```ts
const scope = scopeDefine({
  title: 'Hello',
  items: ['a', 'b'],
  $tpl: prolit_html`
    <h1>{{ title }}</h1>
    <ul><li *for="x of items">{{ x }}</li></ul>
  `,
});
```

## litEnv

Signature
```ts
function litEnv(): { html, repeat, when, styleMap, classMap }
```

- Returns utilities used by generated renderers.

Error handling
- `ProLitTemplate.render()` augments thrown errors with the generated-function source line for easier debugging.